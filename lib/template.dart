// Copyright (c) 2015, the Dogma Project Authors.
// Please see the AUTHORS file for details. All rights reserved.
// Use of this source code is governed by a zlib license that can be found in
// the LICENSE file.

/// Functionality for working with mustache templates.
library dogma_codegen.template;

//---------------------------------------------------------------------
// Standard libraries
//---------------------------------------------------------------------

import 'dart:async';

//---------------------------------------------------------------------
// Imports
//---------------------------------------------------------------------

import 'package:dart_style/dart_style.dart';
import 'package:mustache/mustache.dart';
import 'package:resource/resource.dart';

import 'metadata.dart';
import 'path.dart';

import 'src/template/class_declaration.dart';

//---------------------------------------------------------------------
// Library contents
//---------------------------------------------------------------------

/// The header to use.
///
/// The header is typically used to hold copyright information. It is assumed
/// that it contains lines that are commented out.
String header = '';
/// The formatter to use when processing code.
DartFormatter _formatter;
/// The template to use for rendering.
Template _template;
/// The generated header text.
///
/// This is used to determine if the source is generated.
final String _generatedHeaderText = '// Generated by Dogma Dart. DO NOT MODIFY!';
/// The generated header.
final String _generatedHeader =
'''$_generatedHeaderText
// ${new DateTime.now().toString()}
''';

bool isGeneratedSource(List<String> lines) {
  return _generatedHeaderText == lines[0];
}

/// Initializes the formatter to use to process source code.
///
/// If [lineEnding] is given, that will be used for any newlines in the
/// output. Otherwise, the line separator will be inferred from the line
/// endings in the source file.
///
/// If [pageWidth] is given then that will be the maximum number of characters
/// allowed on a line.
///
/// If [indent] is given, that many levels of indentation will be prefixed
/// before each resulting line in the output.
void formatter({String lineEnding, int pageWidth, int indent: 0}) {
  _formatter = new DartFormatter(lineEnding: lineEnding, pageWidth: pageWidth, indent: indent);
}

/// Sets the [source] to use for the template.
///
/// This will overwrite the current template and any subsequent calls to
/// [renderLibrary] will use this template.
///
/// The template is expected to be able to handle the following data structure
/// which mirrors the contents of a .dart file.
///
///     {
///       'generatedHeader': '...'       // String containing the generated definition
///       'header': '...'                // Copyright header
///       'libraryName': '...'           // The name of the library
///       'standardLibraries': {
///         'libraries': ['..',...,'..'] // A list of standard libraries
///       },
///       'imports' {
///         'packages': ['..',...,'..'], // A list of package imports
///         'relative': ['..',...,'..'], // A list of relative package imports
///       },
///       'exports' {
///         'packages': ['..',...,'..'], // A list of package exports
///         'relative': ['..',...,'..'], // A list of relative package exports
///       },
///       'code': '...'                  // Source code for the library
///     }
void templateSource(String source) {
  _template = new Template(source);
}

/// Renders the source code for the [library] with the given [source] contents.
///
/// The value of [source] will be run through the dart style formatter. The
/// behavior of the formatting can be changed through [formatter].
String renderLibrary(LibraryMetadata library, String source) {
  // If not specified use the default template
  if (_template == null) {
    templateSource(_defaultSource);
  }

  // If not specified use the default formatter
  if (_formatter == null) {
    formatter();
  }

  // Get the library imports/exports
  var values = _libraryTemplateValues(library);

  // Append the additional values
  values['generatedHeader'] = _generatedHeader;
  values['header'] = header;
  values['code'] = source;

  // Render out the template
  return _formatter.format(_template.renderString(values));
}

Map _libraryTemplateValues(LibraryMetadata metadata) {
  var values = {
      'libraryName': metadata.name
  };

  // Get the directory containing the library
  var libraryDirectory = dirname(metadata.uri);

  // Get information on the imports
  var standardLibraries = [];
  var packageImports = [];
  var relativeImports = [];

  for (var import in metadata.imported) {
    var uri = import.uri;

    switch (uri.scheme) {
      case 'dart':
        standardLibraries.add(uri.toString());
        break;
      case 'package':
        packageImports.add(uri.toString());
        break;
      case 'file':
        relativeImports.add(relative(uri, from: libraryDirectory));
        break;
    }
  }

  // Sort the libraries into alphabetical order
  standardLibraries.sort();
  packageImports.sort();
  relativeImports.sort();

  // Add the standardLibraries information if applicable
  values['standardLibraries'] = standardLibraries.isNotEmpty
      ? { 'libraries': standardLibraries }
      : null;

  // Add the imports information if applicable
  values['imports'] = packageImports.isNotEmpty || relativeImports.isNotEmpty
      ? { 'packages': packageImports, 'relative': relativeImports }
      : null;

  // Get information on the exports
  var packageExports = [];
  var relativeExports = [];

  for (var export in metadata.exported) {
    var uri = export.uri;

    switch (uri.scheme) {
      case 'package':
        packageExports.add(uri.toString());
        break;
      case 'file':
        relativeExports.add(relative(uri, from: libraryDirectory));
        break;
    }
  }

  // Sort the libraries into alphabetical order
  packageExports.sort();
  relativeExports.sort();

  // Add the exports information if applicable
  values['exports'] = packageExports.isNotEmpty || relativeExports.isNotEmpty
      ? { 'packages': packageExports, 'relative': relativeExports }
      : null;

  return values;
}

/// The default template source for code generation.
final String _defaultSource =
'''{{{generatedHeader}}}
{{{header}}}


library {{libraryName}};

{{#standardLibraries}}

//---------------------------------------------------------------------
// Standard libraries
//---------------------------------------------------------------------


{{#libraries}}
import '{{{.}}}';
{{/libraries}}
{{/standardLibraries}}
{{#imports}}

//---------------------------------------------------------------------
// Imports
//---------------------------------------------------------------------


{{#packages}}
import '{{{.}}}';
{{/packages}}
{{#relative}}
import '{{{.}}}';
{{/relative}}
{{/imports}}
{{#exports}}

//---------------------------------------------------------------------
// Exports
//---------------------------------------------------------------------


{{#packages}}
export '{{{.}}}';
{{/packages}}
{{#relative}}
export '{{{.}}}';
{{/relative}}
{{/exports}}

//---------------------------------------------------------------------
// Library contents
//---------------------------------------------------------------------


{{{code}}}''';

Future<Null> initializeTemplates({String codeHeader,
                                 String classTemplate: defaultClassTemplate}) async
{
  header = codeHeader;
  await setClassTemplate(classTemplate);
}

Future<Null> setClassTemplate(String classTemplate) async {
  var resource = new Resource(classTemplate);
  var contents = await resource.readAsString();

  classTemplateSource(contents);
}
